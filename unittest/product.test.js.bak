const { expect } = require('chai');
const sinon = require('sinon');
const mongoose = require('mongoose');
const { ObjectId } = mongoose.Types;

// Import the modules to test
const ProductFactory = require('../src/services/product.service.pattern');
const { apiKey, permission } = require('../src/auth/checkAuth');
const { NotFoundError } = require('../src/core/error.respone');
const {
  findAllDraftedForShop,
  publishProductByShop,
  searchProductByUser,
  findAllPublishedForShop,
  unPublishProductByShop,
  findAllProducts,
  createProduct,
  createClothing,
  createElectronic,
  createFurniture,
  updateProductById,
  updateClothingById,
  updateElectronicById,
  updateFurnitureById,
  findProductById,
  deleteProductById
} = require('../src/models/repositories/product.repo');

// Mocks for mongoose models
const mockProductModel = {
  create: sinon.stub(),
  findOne: sinon.stub(),
  find: sinon.stub(),
  findById: sinon.stub(),
  findByIdAndUpdate: sinon.stub(),
  findByIdAndDelete: sinon.stub(),
  lean: sinon.stub(),
  exec: sinon.stub(),
  populate: sinon.stub(),
  sort: sinon.stub(),
  skip: sinon.stub(),
  limit: sinon.stub(),
  select: sinon.stub(),
  save: sinon.stub(),
  countDocuments: sinon.stub()
};

// Stub the repository functions
const repositoryStubs = {
  findAllDraftedForShop: sinon.stub(),
  publishProductByShop: sinon.stub(),
  searchProductByUser: sinon.stub(),
  findAllPublishedForShop: sinon.stub(),
  unPublishProductByShop: sinon.stub(),
  findAllProducts: sinon.stub(),
  createProduct: sinon.stub(),
  createClothing: sinon.stub(),
  createElectronic: sinon.stub(),
  createFurniture: sinon.stub(),
  updateProductById: sinon.stub(),
  updateClothingById: sinon.stub(),
  updateElectronicById: sinon.stub(),
  updateFurnitureById: sinon.stub(),
  findProductById: sinon.stub(),
  deleteProductById: sinon.stub()
};

// Mock data
const mockShopId = new ObjectId().toString();

const mockProducts = {
  clothing: {
    _id: new ObjectId().toString(),
    product_name: "Test Clothing",
    product_thumb: "https://example.com/clothing.jpg",
    product_description: "A test clothing product",
    product_price: 199,
    product_quantity: 50,
    product_type: "Clothing",
    product_shop: mockShopId,
    product_attributes: {
      brand: "Test Brand",
      size: "M",
      material: "Cotton"
    },
    isDraft: true,
    isPublished: false
  },
  electronic: {
    _id: new ObjectId().toString(),
    product_name: "Test Electronic",
    product_thumb: "https://example.com/electronic.jpg",
    product_description: "A test electronic product",
    product_price: 999,
    product_quantity: 20,
    product_type: "Electronic",
    product_shop: mockShopId,
    product_attributes: {
      manufacturer: "Test Manufacturer",
      model: "Test Model",
      color: "Black"
    },
    isDraft: true,
    isPublished: false
  },
  furniture: {
    _id: new ObjectId().toString(),
    product_name: "Test Furniture",
    product_thumb: "https://example.com/furniture.jpg",
    product_description: "A test furniture product",
    product_price: 599,
    product_quantity: 10,
    product_type: "Furniture",
    product_shop: mockShopId,
    product_attributes: {
      brand: "Test Furniture Brand",
      material: "Wood",
      size: "200x100x75 cm"
    },
    isDraft: true,
    isPublished: false
  }
};

const mockProductSearchResults = [
  { _id: new ObjectId().toString(), product_name: "Product 1", product_price: 100 },
  { _id: new ObjectId().toString(), product_name: "Product 2", product_price: 200 },
];

describe('Unit Tests for Product Management System', function() {
  // Reset stubs before each test
  beforeEach(() => {
    sinon.reset();
  });

  afterEach(() => {
    sinon.restore();
  });
  },
  furniture: {
    _id: new ObjectId().toString(),
    product_name: "Test Furniture",
    product_thumb: "https://example.com/furniture.jpg",
    product_description: "A test furniture product",
    product_price: 599,
    product_quantity: 10,
    product_type: "Furniture",
    product_shop: mockShopId,
    product_attributes: {
      brand: "Test Furniture Brand",
      material: "Wood",
      size: "200x100x75 cm"
    },
    isDraft: true,
    isPublished: false
  }
};

const mockProductSearchResults = [
  { _id: new ObjectId().toString(), product_name: "Product 1", product_price: 100 },
  { _id: new ObjectId().toString(), product_name: "Product 2", product_price: 200 },
];

describe('Unit Tests for Product Management System', function() {
  // Reset stubs before each test
  beforeEach(() => {
    sinon.reset();
  });

  afterEach(() => {
    sinon.restore();
  });

  describe('ProductFactory Service Tests', () => {
    /**
     * Product validation tests
     */
    describe('Product Validation', () => {
      it('should validate Clothing product data correctly', () => {
        // Test valid clothing data
        const validClothing = {
          product_name: "Test Clothing",
          product_thumb: "https://example.com/clothing.jpg",
          product_price: 199,
          product_quantity: 50,
          product_attributes: {
            brand: "Test Brand",
            size: "M",
            material: "Cotton"
          }
        };
        
        expect(() => ProductFactory.validateProductData('Clothing', validClothing)).to.not.throw();
        
        // Test invalid clothing data (missing brand)
        const invalidClothing = {
          product_name: "Test Clothing",
          product_thumb: "https://example.com/clothing.jpg",
          product_price: 199,
          product_quantity: 50,
          product_attributes: {
            size: "M",
            material: "Cotton"
          }
        };
        
        expect(() => ProductFactory.validateProductData('Clothing', invalidClothing)).to.throw(NotFoundError);
      });
      it('should validate Electronic product data correctly', () => {
        // Test valid electronic data
        const validElectronic = {
          product_name: "Test Electronic",
          product_thumb: "https://example.com/electronic.jpg",
          product_price: 999,
          product_quantity: 20,
          product_attributes: {
            manufacturer: "Test Manufacturer",
            model: "Test Model",
            color: "Black"
          }
        };
        
        expect(() => ProductFactory.validateProductData('Electronic', validElectronic)).to.not.throw();
        
        // Test invalid electronic data (missing model)
        const invalidElectronic = {
          product_name: "Test Electronic",
          product_thumb: "https://example.com/electronic.jpg",
          product_price: 999,
          product_quantity: 20,
          product_attributes: {
            manufacturer: "Test Manufacturer",
            color: "Black"
          }
        };
        
        expect(() => ProductFactory.validateProductData('Electronic', invalidElectronic)).to.throw(NotFoundError);
      });

      it('should validate Furniture product data correctly', () => {
        // Test valid furniture data
        const validFurniture = {
          product_name: "Test Furniture",
          product_thumb: "https://example.com/furniture.jpg",
          product_price: 599,
          product_quantity: 10,
          product_attributes: {
            brand: "Test Furniture Brand",
            material: "Wood",
            size: "200x100x75 cm"
          }
        };
        
        expect(() => ProductFactory.validateProductData('Furniture', validFurniture)).to.not.throw();
        
        // Test invalid furniture data (missing material)
        const invalidFurniture = {
          product_name: "Test Furniture",
          product_thumb: "https://example.com/furniture.jpg",
          product_price: 599,
          product_quantity: 10,
          product_attributes: {
            brand: "Test Furniture Brand",
            size: "200x100x75 cm"
          }
        };
        
        expect(() => ProductFactory.validateProductData('Furniture', invalidFurniture)).to.throw(NotFoundError);
      });

      it('should validate common required fields for all product types', () => {
        // Missing required field (product_name)
        const missingName = {
          product_thumb: "https://example.com/clothing.jpg",
          product_price: 199,
          product_quantity: 50,
          product_attributes: {
            brand: "Test Brand",
            size: "M",
            material: "Cotton"
          }
        };
        
        expect(() => ProductFactory.validateProductData('Clothing', missingName)).to.throw(NotFoundError);
        
        // Missing required field (product_price)
        const missingPrice = {
          product_name: "Test Clothing",
          product_thumb: "https://example.com/clothing.jpg",
          product_quantity: 50,
          product_attributes: {
            brand: "Test Brand",
            size: "M",
            material: "Cotton"
          }
        };
        
        expect(() => ProductFactory.validateProductData('Clothing', missingPrice)).to.throw(NotFoundError);
      });
    });

    /**
     * Product creation tests
     */
    describe('Product Creation', () => {
      it('should create a clothing product successfully', async () => {
        const productData = {
          product_name: "Test Clothing",
          product_thumb: "https://example.com/clothing.jpg",
          product_description: "A test clothing product",
          product_price: 199,
          product_quantity: 50,
          product_shop: mockShopId,
          product_attributes: {
            brand: "Test Brand",
            size: "M",
            material: "Cotton"
          }
        };

        // Setup stubs
        const clothingId = new ObjectId().toString();
        repositoryStubs.createClothing.resolves({ _id: clothingId });
        repositoryStubs.createProduct.resolves({
          ...productData,
          _id: clothingId,
          product_type: "Clothing",
          isDraft: true,
          isPublished: false
        });
        
        // Replace actual functions with stubs for this test
        const originals = {
          createClothing: global.createClothing,
          createProduct: global.createProduct
        };
        
        global.createClothing = repositoryStubs.createClothing;
        global.createProduct = repositoryStubs.createProduct;
        
        try {
          const result = await ProductFactory.createProduct('Clothing', productData);
          
          expect(repositoryStubs.createClothing.calledOnce).to.be.true;
          expect(repositoryStubs.createProduct.calledOnce).to.be.true;
          expect(result).to.have.property('_id', clothingId);
          expect(result).to.have.property('product_type', 'Clothing');
          expect(result.isDraft).to.be.true;
          expect(result.isPublished).to.be.false;
        } finally {
          // Restore original functions
          global.createClothing = originals.createClothing;
          global.createProduct = originals.createProduct;
        }
      });
    
    it('should publish a product successfully', async () => {
      // Setup stubs
      repositoryStubs.publishProductByShop.resolves({
        ...mockProducts.clothing,
        isDraft: false,
        isPublished: true
      });
      
      // Replace actual function with stub for this test
      const originalFn = publishProductByShop;
      global.publishProductByShop = repositoryStubs.publishProductByShop;
      
      try {
        const result = await ProductFactory.publishProductByShop({
          product_shop: mockProducts.clothing.product_shop,
          product_id: mockProducts.clothing._id
        });
        
        expect(repositoryStubs.publishProductByShop.calledOnce).to.be.true;
        expect(result.isDraft).to.be.false;
        expect(result.isPublished).to.be.true;
      } finally {
        // Restore original function
        global.publishProductByShop = originalFn;
      }
    });
    
    it('should find all drafted products for a shop', async () => {
      // Setup stubs
      repositoryStubs.findAllDraftedForShop.resolves([mockProducts.clothing, mockProducts.electronic]);
      
      // Replace actual function with stub for this test
      const originalFn = findAllDraftedForShop;
      global.findAllDraftedForShop = repositoryStubs.findAllDraftedForShop;
      
      try {
        const result = await ProductFactory.findAllDraftForShop({
          product_shop: mockProducts.clothing.product_shop,
          limit: 10,
          skip: 0
        });
        
        expect(repositoryStubs.findAllDraftedForShop.calledOnce).to.be.true;
        expect(result).to.be.an('array').with.lengthOf(2);
      } finally {
        // Restore original function
        global.findAllDraftedForShop = originalFn;
      }
    });
  });
  
  describe('Middleware Tests', () => {
    /**
     * API Key middleware tests
     */
    describe('API Key Middleware', () => {
      it('should validate API key correctly', async () => {
        const req = {
          headers: {
            'x-api-key': 'valid-api-key'
          }
        };
        const res = {
          status: sinon.stub().returnsThis(),
          json: sinon.stub()
        };
        const next = sinon.spy();
        
        // Mock the findApiKeyById function
        const findApiKeyById = sinon.stub().resolves({
          key: 'valid-api-key',
          permissions: ['0000'],
          status: true
        });
        
        // Temporarily replace the imported function
        const apiKeyWithMock = apiKey.bind({ findApiKeyById });
        
        await apiKeyWithMock(req, res, next);
        
        expect(next.calledOnce).to.be.true;
        expect(req.objKey).to.deep.equal({
          key: 'valid-api-key',
          permissions: ['0000'],
          status: true
        });
      });
      
      it('should reject missing API key', async () => {
        const req = {
          headers: {}
        };
        const res = {
          status: sinon.stub().returnsThis(),
          json: sinon.stub()
        };
        const next = sinon.spy();
        
        // Mock the findApiKeyById function
        const findApiKeyById = sinon.stub();
        
        // Temporarily replace the imported function
        const apiKeyWithMock = apiKey.bind({ findApiKeyById });
        
        await apiKeyWithMock(req, res, next);
        
        expect(next.called).to.be.false;
        expect(res.status.calledWith(403)).to.be.true;
        expect(res.json.calledWith({ message: 'Forbidden Error' })).to.be.true;
        expect(findApiKeyById.called).to.be.false; // Should not even call findApiKeyById
      });
      
      it('should reject invalid API key', async () => {
        const req = {
          headers: {
            'x-api-key': 'invalid-api-key'
          }
        };
        const res = {
          status: sinon.stub().returnsThis(),
          json: sinon.stub()
        };
        const next = sinon.spy();
        
        // Mock the findApiKeyById function
        const findApiKeyById = sinon.stub().resolves(null);
        
        // Temporarily replace the imported function
        const apiKeyWithMock = apiKey.bind({ findApiKeyById });
        
        await apiKeyWithMock(req, res, next);
        
        expect(next.called).to.be.false;
        expect(res.status.calledWith(403)).to.be.true;
        expect(res.json.calledWith({ message: 'Forbidden Error' })).to.be.true;
        expect(findApiKeyById.calledOnce).to.be.true;
        expect(findApiKeyById.calledWith('invalid-api-key')).to.be.true;
      });
    });

    /**
     * Permission middleware tests
     */
    describe('Permission Middleware', () => {
      it('should check valid permissions correctly', () => {
        const req = {
          objKey: {
            permissions: ['0000', '1111']
          }
        };
        const res = {
          status: sinon.stub().returnsThis(),
          json: sinon.stub()
        };
        const next = sinon.spy();
        
        // Test with valid permission
        const checkPermission = permission('0000');
        checkPermission(req, res, next);
        
        expect(next.calledOnce).to.be.true;
        expect(res.status.called).to.be.false;
        expect(res.json.called).to.be.false;
      });
      
      it('should reject invalid permissions', () => {
        const req = {
          objKey: {
            permissions: ['0000', '1111']
          }
        };
        const res = {
          status: sinon.stub().returnsThis(),
          json: sinon.stub()
        };
        const next = sinon.spy();
        
        // Test with invalid permission
        const checkInvalidPermission = permission('2222');
        checkInvalidPermission(req, res, next);
        
        expect(next.called).to.be.false;
        expect(res.status.calledWith(403)).to.be.true;
        expect(res.json.calledWith({ message: 'Forbidden Denied' })).to.be.true;
      });
      
      it('should reject when permissions are missing', () => {
        const req = {
          objKey: {}
        };
        const res = {
          status: sinon.stub().returnsThis(),
          json: sinon.stub()
        };
        const next = sinon.spy();
        
        // Test with missing permissions
        const checkPermission = permission('0000');
        checkPermission(req, res, next);
        
        expect(next.called).to.be.false;
        expect(res.status.calledWith(403)).to.be.true;
        expect(res.json.calledWith({ message: 'Forbidden Denied' })).to.be.true;
      });
    });
  });
  
  describe('Repository Tests', () => {
    /**
     * Product query tests
     */
    describe('Product Query Functions', () => {
      it('should find a product by ID correctly', async () => {
        // Setup stub
        const foundProduct = { ...mockProducts.clothing };
        mockProductModel.findById.returns({
          lean: () => foundProduct
        });
        
        // Create a sandboxed version of findProductById with mocked mongoose model
        const sandboxedFindProductById = async (productId) => {
          return await mockProductModel.findById(productId).lean();
        };
        
        const result = await sandboxedFindProductById(mockProducts.clothing._id);
        
        expect(result).to.deep.equal(foundProduct);
        expect(mockProductModel.findById.calledWith(mockProducts.clothing._id)).to.be.true;
      });
      
      it('should search products by text correctly', async () => {
        // Setup stubs
        mockProductModel.find.returns({
          sort: () => mockProductModel,
          skip: () => mockProductModel,
          limit: () => mockProductModel,
          lean: () => mockProductModel,
          exec: () => mockProductSearchResults
        });
        
        // Create a sandboxed version of searchProductByUser
        const sandboxedSearchProductByUser = async ({ keySearch, limit, skip }) => {
          const regexSearch = new RegExp(keySearch);
          return await mockProductModel.find({
            $text: { $search: regexSearch },
          }, {
            score: { $meta: 'textScore' }
          })
            .sort({ score: { $meta: 'textScore' } })
            .skip(skip)
            .limit(limit)
            .lean()
            .exec();
        };
        
        const result = await sandboxedSearchProductByUser({ 
          keySearch: 'test keyword',
          limit: 50,
          skip: 0 
        });
        
        expect(result).to.deep.equal(mockProductSearchResults);
        expect(mockProductModel.find.calledOnce).to.be.true;
      });
      
      it('should find all products with filtering and pagination', async () => {
        // Setup stubs
        mockProductModel.find.returns({
          sort: () => mockProductModel,
          skip: () => mockProductModel,
          limit: () => mockProductModel,
          select: () => mockProductModel,
          lean: () => mockProductModel,
          exec: () => mockProductSearchResults
        });
        
        mockProductModel.countDocuments.resolves(10);
        
        // Create a sandboxed version of findAllProducts
        const sandboxedFindAllProducts = async ({ limit, sort, page, filter, select }) => {
          const skip = (page - 1) * limit;
          const sortBy = sort === 'ctime' ? { _id: -1 } : { _id: 1 };
          
          const products = await mockProductModel.find(filter)
            .sort(sortBy)
            .skip(skip)
            .limit(limit)
            .select(select)
            .lean()
            .exec();
          
          const countProducts = await mockProductModel.countDocuments(filter);
          
          return {
            products,
            total: countProducts
          };
        };
        
        const result = await sandboxedFindAllProducts({
          limit: 10,
          sort: 'ctime',
          page: 1,
          filter: { product_price: { $gt: 100 } },
          select: ['product_name', 'product_price']
        });
        
        expect(result).to.have.property('products').that.deep.equals(mockProductSearchResults);
        expect(result).to.have.property('total', 10);
        expect(mockProductModel.find.calledOnce).to.be.true;
        expect(mockProductModel.countDocuments.calledOnce).to.be.true;
      });
    });

    /**
     * Product mutation tests
     */
    describe('Product Mutation Functions', () => {
      it('should create a product correctly', async () => {
        // Setup stub
        mockProductModel.create.resolves(mockProducts.clothing);
        
        // Create a sandboxed version of createProduct with mocked mongoose model
        const sandboxedCreateProduct = async (productData) => {
          return await mockProductModel.create(productData);
        };
        
        const result = await sandboxedCreateProduct(mockProducts.clothing);
        
        expect(result).to.deep.equal(mockProducts.clothing);
        expect(mockProductModel.create.calledWith(mockProducts.clothing)).to.be.true;
      });
      
      it('should update a product correctly', async () => {
        // Setup stub
        const updatedProduct = { 
          ...mockProducts.clothing, 
          product_name: 'Updated Product',
          product_price: 299
        };
        
        mockProductModel.findByIdAndUpdate.resolves(updatedProduct);
        
        // Create a sandboxed version of updateProductById
        const sandboxedUpdateProductById = async (productId, bodyUpdate, options) => {
          return await mockProductModel.findByIdAndUpdate(productId, bodyUpdate, options);
        };
        
        const result = await sandboxedUpdateProductById(
          mockProducts.clothing._id, 
          { product_name: 'Updated Product', product_price: 299 },
          { new: true }
        );
        
        expect(result).to.deep.equal(updatedProduct);
        expect(mockProductModel.findByIdAndUpdate.calledOnce).to.be.true;
        expect(mockProductModel.findByIdAndUpdate.firstCall.args[0]).to.equal(mockProducts.clothing._id);
        expect(mockProductModel.findByIdAndUpdate.firstCall.args[1]).to.deep.equal({ 
          product_name: 'Updated Product', 
          product_price: 299 
        });
        expect(mockProductModel.findByIdAndUpdate.firstCall.args[2]).to.deep.equal({ new: true });
      });
      
      it('should delete a product correctly', async () => {
        // Setup stub
        mockProductModel.findByIdAndDelete.resolves(mockProducts.clothing);
        
        // Create a sandboxed version of deleteProductById with mocked mongoose model
        const sandboxedDeleteProductById = async (productId) => {
          return await mockProductModel.findByIdAndDelete(productId);
        };
        
        const result = await sandboxedDeleteProductById(mockProducts.clothing._id);
        
        expect(result).to.deep.equal(mockProducts.clothing);
        expect(mockProductModel.findByIdAndDelete.calledWith(mockProducts.clothing._id)).to.be.true;
      });
      
      it('should publish a product correctly', async () => {
        // Setup stub
        const product = { 
          ...mockProducts.clothing, 
          isDraft: true, 
          isPublished: false,
          save: sinon.stub().resolves({ 
            ...mockProducts.clothing, 
            isDraft: false, 
            isPublished: true 
          })
        };
        
        mockProductModel.findOne.resolves(product);
        
        // Create a sandboxed version of publishProductByShop with mocked mongoose model
        const sandboxedPublishProductByShop = async ({ product_shop, product_id }) => {
          const foundShop = await mockProductModel.findOne({
            product_shop: new mongoose.Types.ObjectId(product_shop),
            _id: new mongoose.Types.ObjectId(product_id)
          });
          
          if (!foundShop) {
            return null;
          }
          
          foundShop.isDraft = false;
          foundShop.isPublished = true;
          
          await foundShop.save();
          
          return foundShop;
        };
        
        const result = await sandboxedPublishProductByShop({
          product_shop: mockShopId,
          product_id: mockProducts.clothing._id
        });
        
        expect(result.isDraft).to.be.false;
        expect(result.isPublished).to.be.true;
        expect(mockProductModel.findOne.calledOnce).to.be.true;
        expect(product.save.calledOnce).to.be.true;
      });
      
      it('should unpublish a product correctly', async () => {
        // Setup stub
        const product = { 
          ...mockProducts.clothing, 
          isDraft: false, 
          isPublished: true,
          save: sinon.stub().resolves({ 
            ...mockProducts.clothing, 
            isDraft: true, 
            isPublished: false 
          })
        };
        
        mockProductModel.findOne.resolves(product);
        
        // Create a sandboxed version of unPublishProductByShop with mocked mongoose model
        const sandboxedUnPublishProductByShop = async ({ product_shop, product_id }) => {
          const foundShop = await mockProductModel.findOne({
            product_shop: new mongoose.Types.ObjectId(product_shop),
            _id: new mongoose.Types.ObjectId(product_id)
          });
          
          if (!foundShop) {
            return null;
          }
          
          foundShop.isDraft = true;
          foundShop.isPublished = false;
          
          await foundShop.save();
          
          return foundShop;
        };
        
        const result = await sandboxedUnPublishProductByShop({
          product_shop: mockShopId,
          product_id: mockProducts.clothing._id
        });
        
        expect(result.isDraft).to.be.true;
        expect(result.isPublished).to.be.false;
        expect(mockProductModel.findOne.calledOnce).to.be.true;
        expect(product.save.calledOnce).to.be.true;
      });
    });
  });